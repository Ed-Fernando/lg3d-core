/**
 * Project Looking Glass
 *
 * $RCSfile: Bounds.java,v $
 *
 * Copyright (c) 2004, Sun Microsystems, Inc., All Rights Reserved
 *
 * Redistributions in source code form must reproduce the above
 * copyright and this condition.
 *
 * The contents of this file are subject to the GNU General Public
 * License, Version 2 (the "License"); you may not use this file
 * except in compliance with the License. A copy of the License is
 * available at http://www.opensource.org/licenses/gpl-license.php.
 *
 * $Revision: 1.2 $
 * $Date: 2004-06-23 18:51:03 $
 * $State: Exp $
 */
package org.jdesktop.lg3d.sg.internal.rmi.rmiserver;

import javax.vecmath.*;
import java.lang.Math;
import java.util.HashMap;
import java.rmi.server.UnicastRemoteObject;

/**
 * The abstract base class for bounds objects.  Bounds objects define
 * a convex, closed volume that is used for various intersection and
 * culling operations.
 */

public abstract class Bounds extends UnicastRemoteObject implements BoundsRemote {
    static final double EPSILON = .000001;
    static final boolean debug = false;

    static final int BOUNDING_BOX = 0x1;
    static final int BOUNDING_SPHERE = 0x2;
    static final int BOUNDING_POLYTOPE = 0x4;

    org.jdesktop.lg3d.sg.Bounds wrapped;
    
    protected java.util.logging.Logger logger = java.util.logging.Logger.getLogger("lg.sg");
    
    /**
     * Bounds does not have user data so this structure lets us
     * determine the LG Bounds object for a given Java3D Bounds
     */
    protected static HashMap reverseLookup = new HashMap();
    
    /**
     * Constructs a new Bounds object.
     */
    public Bounds() throws java.rmi.RemoteException {
        createWrapped();
    }
    
    protected abstract void createWrapped();


    /**
     * Makes a copy of a bounds object. 
     */
    //public abstract Object clone();


  /**
   * Test for intersection with a ray.
   * @param origin the starting point of the ray
   * @param direction the direction of the ray
   * @return true or false indicating if an intersection occured
   */
  //public abstract boolean intersect( Point3d origin, Vector3d direction );

   /**
    * Test for intersection with a point.
    * @param point a point defining a position in 3-space
    * @return true or false indicating if an intersection occured
    */
  //public abstract boolean intersect( Point3d point );


    /**
     * Test for intersection with another bounds object.
     * @param boundsObject another bounds object
     * @return true or false indicating if an intersection occurred
     */
  public abstract boolean intersect( BoundsRemote boundsObject ) throws java.rmi.RemoteException; 

    /**
     * Test for intersection with another bounds object.
     * @param boundsObjects an array of bounding objects
     * @return true or false indicating if an intersection occured
     */
  public abstract boolean intersect( BoundsRemote[] boundsObjects ) throws java.rmi.RemoteException;

   
     /**
     * Finds closest bounding object that intersects this bounding object.
     * @param boundsObjects an array of  bounds objects
     * @return closest bounding object
     */  
  public abstract BoundsRemote closestIntersection( BoundsRemote[] boundsObjects) throws java.rmi.RemoteException; 


     /**
      * Combines this bounding object with a bounding object so that the
      * resulting bounding object encloses the original bounding object and the
      * given bounds object.
      * @param boundsObject another bounds object
      */ 
  public abstract void combine( BoundsRemote   boundsObject ) throws java.rmi.RemoteException;


     /** 
      * Combines this bounding object with an array of bounding objects so that the
      * resulting bounding object encloses the original bounding object and the
      * given array of bounds object.
      * @param boundsObjects an array of bounds objects
      */ 
  public abstract void combine( BoundsRemote[] boundsObjects) throws java.rmi.RemoteException;


  /**
   * Transforms this bounding object by the given matrix.
   * @param trans the transformation matrix
   */
  public abstract void transform(Transform3DRemote trans) throws java.rmi.RemoteException;

     /**
      * Modifies the bounding object so that it bounds the volume
      * generated by transforming the given bounding object.
      * @param bounds the bounding object to be transformed
      * @param trans the transformation matrix
      */ 
  public abstract void transform( BoundsRemote bounds, Transform3DRemote trans) throws java.rmi.RemoteException;

    /**
     * Tests whether the bounds is empty.  A bounds is
     * empty if it is null (either by construction or as the result of
     * a null intersection) or if its volume is negative.  A bounds
     * with a volume of zero is <i>not</i> empty.
     * @return true if the bounds is empty; otherwise, it returns false
     */
    public abstract boolean isEmpty() throws java.rmi.RemoteException;

  /**
   * Sets the value of this Bounds object.
   * @param boundsObject another bounds object. 
   */
  public abstract void set( BoundsRemote boundsObject) throws java.rmi.RemoteException;
  
  /**
   * Returns the looking glass bounds given a java3d bounds
   */
  static Bounds getLGBounds( org.jdesktop.lg3d.sg.Bounds j3dBounds ) {
      return (Bounds)reverseLookup.get( j3dBounds );
  }

}
