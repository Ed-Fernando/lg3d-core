/**
 * Project Looking Glass
 *
 * $RCSfile: BoundingSphere.java,v $
 *
 * Copyright (c) 2004, Sun Microsystems, Inc., All Rights Reserved
 *
 * Redistributions in source code form must reproduce the above
 * copyright and this condition.
 *
 * The contents of this file are subject to the GNU General Public
 * License, Version 2 (the "License"); you may not use this file
 * except in compliance with the License. A copy of the License is
 * available at http://www.opensource.org/licenses/gpl-license.php.
 *
 * $Revision: 1.2 $
 * $Date: 2004-06-23 18:51:03 $
 * $State: Exp $
 */
package org.jdesktop.lg3d.sg.internal.rmi.rmiserver;

import javax.vecmath.Point3f;
import javax.vecmath.Point3d;

/**
 * This class defines a spherical bounding region which is defined by a
 * center point and a radius.
 */

public class BoundingSphere extends Bounds implements BoundingSphereRemote {
	
    public BoundingSphere() throws java.rmi.RemoteException {
    }
    
    /**
     * Constructs and initializes a BoundingSphere from a center and radius.
     * @param center the center of the bounding sphere
     * @param radius the radius of the bounding sphere
     */
    public BoundingSphere(Point3f center, float radius) throws java.rmi.RemoteException {
        setCenter( center );
        setRadius( radius );
    }
    
    protected void createWrapped() {
        wrapped = new org.jdesktop.lg3d.sg.BoundingSphere();
        reverseLookup.put( wrapped, this );
    }
 
    /**
     * Returns the radius of this bounding sphere as a double.
     * @return the radius of the bounding sphere
     */
    public float getRadius() throws java.rmi.RemoteException {
	return (float)((org.jdesktop.lg3d.sg.BoundingSphere)wrapped).getRadius();
    }

    /**
     * Returns the position of this bounding sphere as a point.
     * @param center a Point to receive the center of the bounding sphere
     */
    public void getCenter(Point3f center) throws java.rmi.RemoteException {
	((org.jdesktop.lg3d.sg.BoundingSphere)wrapped).getCenter( center );
    }
    
    /**
     * Sets the value of this BoundingSphere.
     * @param boundsObject another bounds object
     */
    public void set(BoundsRemote  boundsObject) throws java.rmi.RemoteException {
	((org.jdesktop.lg3d.sg.BoundingSphere)wrapped).set( (org.jdesktop.lg3d.sg.Bounds)SGObjectFactoryImpl.getFactoryImpl().getLocal(boundsObject).wrapped );
    }

    /** 
     * Combines this bounding sphere with a bounding object so that the
     * resulting bounding sphere encloses the original bounding sphere and the
     * given bounds object.
     * @param boundsObject another bounds object
     */
    public void combine(BoundsRemote boundsObject) throws java.rmi.RemoteException {
        //((org.jdesktop.lg3d.sg.BoundingSphere)wrapped).combine( (org.jdesktop.lg3d.sg.Bounds)SGObjectFactoryImpl.getFactoryImpl().getLocal(boundsObject).wrapped );
        ((org.jdesktop.lg3d.sg.BoundingSphere)wrapped).combine( ((Bounds)boundsObject).wrapped );
    }
    
    /** 
     * Combines this bounding sphere with an array of bounding objects so that the
     * resulting bounding sphere encloses the original bounding sphere and the
     * given array of bounds object.
     * @param boundsObjects an array of bounds objects
     */
    public void combine(BoundsRemote[] boundsObjects) throws java.rmi.RemoteException {
        throw new RuntimeException("Not Implemented");
    }

    /**
     * Modifies the bounding sphere so that it bounds the volume
     * generated by transforming the given bounding object.
     * @param boundsObject the bounding object to be transformed 
     * @param matrix a transformation matrix
     */
    public void transform( BoundsRemote boundsObject, Transform3DRemote matrix) throws java.rmi.RemoteException {
	((org.jdesktop.lg3d.sg.BoundingSphere)wrapped).transform( 
                        SGObjectFactoryImpl.getFactoryImpl().getLocal(boundsObject).wrapped, 
                        ((Transform3D)matrix).wrapped );
    }

    /** 
     * Transforms this bounding sphere by the given matrix.
     */
    public void transform( Transform3DRemote trans) throws java.rmi.RemoteException {
        ((org.jdesktop.lg3d.sg.BoundingSphere)wrapped).transform( ((Transform3D)trans).wrapped );
    }


    /** 
     * Test for intersection with a ray.
     * @param origin the starting point of the ray
     * @param direction the direction of the ray
     * @return true or false indicating if an intersection occured
     */ 
//    public boolean intersect(Point3d origin, Vector3d direction ) {
//
//	return ((org.jdesktop.lg3d.sg.BoundingSphere)wrapped).intersect( origin, direction );
//    }

    
    /**
     * Test for intersection with a point.
     * @param point a point defining a position in 3-space
     * @return true or false indicating if an intersection occured
     */ 
//    public boolean intersect(Point3d point ) {
//	return ((org.jdesktop.lg3d.sg.BoundingSphere)wrapped).intersect( point );
//    }

    /**
     * Test for intersection with a point.
     * @param point a point defining a position in 3-space
     * @return true or false indicating if an intersection occured
     */ 
    public boolean intersect(Point3f point ) throws java.rmi.RemoteException {
	return ((org.jdesktop.lg3d.sg.BoundingSphere)wrapped).intersect( point );
      
    }

    /**
     * Tests whether the bounding sphere is empty.  A bounding sphere is
     * empty if it is null (either by construction or as the result of
     * a null intersection) or if its volume is negative.  A bounding sphere
     * with a volume of zero is <i>not</i> empty.
     * @return true if the bounding sphere is empty;
     * otherwise, it returns false
     */
    public boolean isEmpty() throws java.rmi.RemoteException {
	return ((org.jdesktop.lg3d.sg.BoundingSphere)wrapped).isEmpty();
    }

    /**
     * Test for intersection with another bounds object.
     * @param boundsObject another bounds object
     * @return true or false indicating if an intersection occured
     */ 
    public boolean intersect(BoundsRemote boundsObject) throws java.rmi.RemoteException {
	return ((org.jdesktop.lg3d.sg.BoundingSphere)wrapped).intersect( SGObjectFactoryImpl.getFactoryImpl().getLocal(boundsObject).wrapped );
    }

    /**
     * Test for intersection with another bounds object.
     * @param boundsObjects an array of bounding objects
     * @return true or false indicating if an intersection occured
     */ 
    public boolean intersect(BoundsRemote[] boundsObjects) throws java.rmi.RemoteException {
	throw new RuntimeException("Not Implemented");
    }    

    /** 
     * Finds closest bounding object that intersects this bounding sphere.
     * @param boundsObjects an array of  bounds objects 
     * @return closest bounding object 
     */
    public BoundsRemote closestIntersection( BoundsRemote[] boundsObjects) throws java.rmi.RemoteException {

	throw new RuntimeException("Not Implemented");

    }

    public void setCenter(Point3f center) throws java.rmi.RemoteException {
        ((org.jdesktop.lg3d.sg.BoundingSphere)wrapped).setCenter( center );
    }
    
    public void setRadius(float radius) throws java.rmi.RemoteException {
        ((org.jdesktop.lg3d.sg.BoundingSphere)wrapped).setRadius( radius );
    }
    
}




