/**
 * Project Looking Glass
 *
 * $RCSfile: BoundingSphere.java,v $
 *
 * Copyright (c) 2004, Sun Microsystems, Inc., All Rights Reserved
 *
 * Redistributions in source code form must reproduce the above
 * copyright and this condition.
 *
 * The contents of this file are subject to the GNU General Public
 * License, Version 2 (the "License"); you may not use this file
 * except in compliance with the License. A copy of the License is
 * available at http://www.opensource.org/licenses/gpl-license.php.
 *
 * $Revision: 1.2 $
 * $Date: 2004-06-23 18:50:48 $
 * $State: Exp $
 */
package org.jdesktop.lg3d.sg.internal.rmi.rmiclient;

import javax.vecmath.Point3f;
import javax.vecmath.Point3d;
import org.jdesktop.lg3d.sg.internal.wrapper.BoundingSphereWrapper;
import org.jdesktop.lg3d.sg.internal.wrapper.BoundsWrapper;
import org.jdesktop.lg3d.sg.internal.wrapper.Transform3DWrapper;
import org.jdesktop.lg3d.sg.internal.rmi.rmiserver.BoundingSphereRemote;

/**
 * This class defines a spherical bounding region which is defined by a
 * center point and a radius.
 */

public class BoundingSphere extends Bounds implements BoundingSphereWrapper {
	
    public BoundingSphere() {
    }
    
    /**
     * Constructs and initializes a BoundingSphere from a center and radius.
     * @param center the center of the bounding sphere
     * @param radius the radius of the bounding sphere
     */
    public BoundingSphere(Point3f center, float radius) {
        setCenter( center );
        setRadius( radius );
    }
    
    protected void createRemote() {
        try {
            remote = SceneGraphSetup.getSGObjectFactory().newBoundingSphere();
            reverseLookup.put( remote, this );
        } catch( java.rmi.RemoteException rex ) {
            throw new RuntimeException(rex);
        }
    }
 
    /**
     * Returns the radius of this bounding sphere as a double.
     * @return the radius of the bounding sphere
     */
    public float getRadius() {
        try {
            return ((BoundingSphereRemote)remote).getRadius();      
        } catch( java.rmi.RemoteException rex ) {
            throw new RuntimeException(rex);
        }
    }

    /**
     * Returns the position of this bounding sphere as a point.
     * @param center a Point to receive the center of the bounding sphere
     */
    public void getCenter(Point3f center) {
        try {
            ((BoundingSphereRemote)remote).getCenter(center);      
        } catch( java.rmi.RemoteException rex ) {
            throw new RuntimeException(rex);
        }
    }
    
    /**
     * Sets the value of this BoundingSphere.
     * @param boundsObject another bounds object
     */
    public void set(BoundsWrapper  boundsObject){
	//((javax.media.j3d.BoundingSphere)wrapped).set( boundsObject.wrapped );
    }
    
    /** 
     * Combines this bounding sphere with a bounding object so that the
     * resulting bounding sphere encloses the original bounding sphere and the
     * given bounds object.
     * @param boundsObject another bounds object
     */
    public void combine(BoundsWrapper boundsObject) {
        //((javax.media.j3d.BoundingSphere)wrapped).combine( boundsObject.wrapped );
        throw new RuntimeException("Not Implemented");
    }
    
    /** 
     * Combines this bounding sphere with an array of bounding objects so that the
     * resulting bounding sphere encloses the original bounding sphere and the
     * given array of bounds object.
     * @param boundsObjects an array of bounds objects
     */
    public void combine(BoundsWrapper[] boundsObjects) {
        throw new RuntimeException("Not Implemented");
    }

    /**
     * Modifies the bounding sphere so that it bounds the volume
     * generated by transforming the given bounding object.
     * @param boundsObject the bounding object to be transformed 
     * @param matrix a transformation matrix
     */
    public void transform( BoundsWrapper boundsObject, Transform3DWrapper matrix) {
//	((javax.media.j3d.BoundingSphere)wrapped).transform( boundsObject.wrapped, matrix.wrapped );
        throw new RuntimeException("Not Implemented");
    }

    /** 
     * Transforms this bounding sphere by the given matrix.
     */
    public void transform( Transform3DWrapper trans) {
//	((javax.media.j3d.BoundingSphere)wrapped).transform( trans.wrapped );
        throw new RuntimeException("Not Implemented");
    }


    /** 
     * Test for intersection with a ray.
     * @param origin the starting point of the ray
     * @param direction the direction of the ray
     * @return true or false indicating if an intersection occured
     */ 
//    public boolean intersect(Point3d origin, Vector3d direction ) {
//
//	return ((javax.media.j3d.BoundingSphere)wrapped).intersect( origin, direction );
//    }

    
    /**
     * Test for intersection with a point.
     * @param point a point defining a position in 3-space
     * @return true or false indicating if an intersection occured
     */ 
//    public boolean intersect(Point3d point ) {
//	return ((javax.media.j3d.BoundingSphere)wrapped).intersect( point );
//    }

    /**
     * Test for intersection with a point.
     * @param point a point defining a position in 3-space
     * @return true or false indicating if an intersection occured
     */ 
    public boolean intersect(Point3f point ) {
        try {
            return ((BoundingSphereRemote)remote).intersect( point );      
        } catch( java.rmi.RemoteException rex ) {
            throw new RuntimeException(rex);
        }
    }

    /**
     * Tests whether the bounding sphere is empty.  A bounding sphere is
     * empty if it is null (either by construction or as the result of
     * a null intersection) or if its volume is negative.  A bounding sphere
     * with a volume of zero is <i>not</i> empty.
     * @return true if the bounding sphere is empty;
     * otherwise, it returns false
     */
    public boolean isEmpty() {
        try {
            return ((BoundingSphereRemote)remote).isEmpty();      
        } catch( java.rmi.RemoteException rex ) {
            throw new RuntimeException(rex);
        }
    }

    /**
     * Test for intersection with another bounds object.
     * @param boundsObject another bounds object
     * @return true or false indicating if an intersection occured
     */ 
    public boolean intersect(BoundsWrapper boundsObject) {
        throw new RuntimeException("Not Implemented");
//	return ((javax.media.j3d.BoundingSphere)wrapped).intersect( boundsObject.wrapped );
    }

    /**
     * Test for intersection with another bounds object.
     * @param boundsObjects an array of bounding objects
     * @return true or false indicating if an intersection occured
     */ 
    public boolean intersect(BoundsWrapper[] boundsObjects) {
	throw new RuntimeException("Not Implemented");
    }    

    /** 
     * Finds closest bounding object that intersects this bounding sphere.
     * @param boundsObjects an array of  bounds objects 
     * @return closest bounding object 
     */
    public BoundsWrapper closestIntersection( BoundsWrapper[] boundsObjects) {

	throw new RuntimeException("Not Implemented");

    }

    public void setCenter(Point3f center) {
        try {
            ((BoundingSphereRemote)remote).setCenter(center);
        } catch( java.rmi.RemoteException rex ) {
            throw new RuntimeException(rex);
        }
    }    

    public void setRadius(float radius) {
        try {
            ((BoundingSphereRemote)remote).setRadius(radius);
        } catch( java.rmi.RemoteException rex ) {
            throw new RuntimeException(rex);
        }
    }    

}




